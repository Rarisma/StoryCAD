# Programmer Notes## General notesStoryBuilder began as a UWP program and now uses Windows UI(WinUI 3) controls and styles and the Windows App SDK. It runsas native Windows (Win32) program, but its UWP roots remain andit uses WinRT APIs and asynchronous IO.It's written in C# and is maintained as a Visual Studiosolution using either VS2022 or VS2019. As we old farts know, regularity is a good thing. That's truefor code as well as people. In code, regularity means doing similar things in a similar fashion, and it's an organizing principle, same as 'Keep it simple, stupid.' If you're adding to StoryBuilder, there's a chance what you'readding is similar to something already there: a Page, A Tab,a Control, new or changed installation data, ## Solution and Project Stucturetba## Installationtba## Developer Tips### Adding a New Control#### Update Page layout to add the new control.    Add a corresponding property to the Page's ViewModel.    Add a 2-way binding from the Page control's Text or SelectedItem to the ViewModel    property.   Initialize the property in the ViewModel's constructor.   If the control is a ComboBox or other control that uses an ItemsSource,  you   also need to add a 1-way binding from the page to that list in the ViewModel,   and to provide a source for the list in the ViewModel. The source will usually   be a list in Controls.ini, which is in the \Assets\Install folder. Use an existing   control as an example. Note that the list must be in the form of key/value pairs.   Test this much and very the layout looks okay. Insure that it's responsive    by resizing the page up and down and checking the layout.## Add the corresponding property to the Model. Name it identically to the ViewModel's property.Initialize the property in each of the Model'sconstructors. Update the ViewModel's LoadModel method to assign the ViewModel's propertyfrom the Model when the ViewModel is activated (navigated to- see BindablePage).If the property is a RichEditBox, call StoryReader.GetRtfText instead using asimple assignment statement (see other rtf fields for an example.)Update the ViewModel's SaveModel method to assign the Model's property fromthe ViewModel when the ViewModel is deactivated (navigated from.) If the property is a RichEditBox, call StoryWriter.PutRtfText instead of a simple assignment.Test that changes to the field persist when you navigate from one StoryElement toanother in the TreeView.## Add code to StoryReader to read the Model property from the .stbx file:   Update the appropriate StoryElement's parse method (called from RecurseStoryElement).   These methods are case statements to find the property's named attribute in the xml   node and move its inner text to the Model's property.## Add code to StoryWriter to write the Model property to the .stbx file.   The appropriate method will named 'ParseXElement', ex., ParseSettingElement.    Use an existing property as a template.   Create a new XmlAttribute.   If the property is a RichEditBox, you must next set the Model's property by calling   PutRtfText.   Assign the attribute with the property's value.   Add the XmlAttribute to the current XmlNode.   Test by using the new property, saving the story outline, re-opening the story project,   and verifying that the data entry from the new control is present and correct.### Creating or Modifying a Tooltba#### Populate the tool's data###StoryBuilder's tools generally provide data to aid in story or character definition or the plotting process. Typically this is reference (read only). Although the data can come from any source, such as a web service, much of it will reside in the StoryBuilder project's \Assets\Install\Tools.ini file. ##Create the model###Create an in-memory model of the data in the StoryBuilderLib project's \Models\Tools folder. These are Plain Old CLR Object (POCO) classes. ##Read the data###Provide a mechanism to read the data  and populate the model. Data in Tools.ini is loaded in StoryBuilderLib \DAL\ToolLoader.cs, which is called from LoadTools() in the StoryBuilder project's App.Xaml.cs. ###Each tool will generally have its own data layout, and ToolLoader.cs consists of a series of methods which load an individual tool's data. If you're accessing data from a different source, such as a web service, you'll probably add the service code under the StoryBuilderLib project's \Services folder, but it should still be called from LoadTools(). ##Create the ViewModel###StoryBuilder uses MVVM for tools as well as regular Page views. We use the Windows Community Toolkit's MVVM library, which is installed as a NuGet package. The ViewModel class must contain a using statement for Microsoft.Toolkit.Mvvm.ComponentModel and derive from ObservableRecipient.##Create the View (Dialog)###The views are generally dialogs and their XAML and code-behind are in StoryBuilderLib's \Services\Dialogs folder. The dialog should 